### Введение: Модули для небольших файлов / Шаблон Модуля

Организация кода очень важна для поддержки крупных проектов.

Обычно существуют определенные правила или логика разделения проектов:

- Изображения в одной папке, CSS в другой папке, а JS в третьей папке.
- Часто файлы JS могут зависеть от других файлов JS напрямую.

#### Пример:

- `math-helpers.js`
  - `getRandomNumber(min, max)`
  - `getOtherRandomNumber(min, max)`
  - `let prevRandom`
- `cool-animations.js` <--- зависит от функций из `math-helpers`
- `feedback-form-stuff.js` <--- зависит от функций из `math-helpers`

Импортирование множества JS файлов в HTML может быть сложно поддерживать и...

... обычно используется система сборки, которая автоматически объединяет файлы!

### Шаблон Модуля

Шаблон Модуля - один из важных шаблонов в JavaScript. Это часто используемый шаблон проектирования, который используется для объединения набора переменных и функций в одной области видимости.

Мы можем сделать некоторые свойства и функции публичными, а также ограничить область видимости свойств и функций внутри самого модуля, делая их приватными.

[Подробнее о скрытии данных с использованием шаблона модуля в JavaScript](https://javascript.plainenglish.io/data-hiding-with-javascript-module-pattern-62b71520bddd)

### Преимущества изоляции области видимости и инкапсуляции

- Шаблоны модулей обеспечивают лучшую поддерживаемость, поскольку весь связанный код может быть инкапсулирован внутри одного логического блока. Эти логически независимые блоки относительно легче обновлять.
- Единый блок кода можно использовать повторно во всем приложении. Функциональность, заключенная в модуль, можно переиспользовать, и нам не нужно определять одни и те же функции в разных местах.
- Вы можете инкапсулировать части вашего приложения в единую концепцию, раскрывая только часть этой концепции наружу, скрывая некоторую сложность.

### Основные идеи

- Изолированные фрагменты кода проще поддерживать.
- Изолированные фрагменты кода проще переиспользовать.
- Изолированные фрагменты кода делают проект проще для разделения.
- Инкапсуляция скрывает сложность частей кода.

### Перед тем как перейти к реальным модулям, рассмотрим еще один метод

#### Краткий обзор IIFE

IIFE = Immediately Invoked Function Expression (немедленно вызываемое функциональное выражение)

- Старый метод создания "фейковых" модулей
- Не настоящие модули
- Потенциальный вопрос на собеседовании
- Существует множество способов это сделать; вот один из быстрых вариантов

Не пишите этот код вживую, вероятно, вам это не понадобится!
- [Подробнее о IIFE на MDN](https://developer.mozilla.org/en-US/docs/Glossary/IIFE)
- [Подробнее о IIFE на Wikipedia](https://en.wikipedia.org/wiki/Immediately_invoked_function_expression)

### Реальные модули / Импорт и Экспорт

Существует два основных способа (нельзя совмещать в одном проекте):

- CommonJS / CJS (не будем рассматривать). Но он существует.
- ECMAScript модули / ESM (мы будем использовать это). Учите CJS только если это необходимо.

Импортирование модулей немного отличается от другого JS в браузере.

Использование модулей в браузере: `<script type="module" src="...">`

### Общие рекомендации по ESM

- Файлы ESM могут иметь расширение .mjs вместо .js - но это часто игнорируется.
- Один модуль на файл.
- Соединение файлов: ключевые слова `import` и `export`.
- Что содержать в модуле - зависит от задачи.
  - Группировка связанных функций ИЛИ класса, например.
  - Используйте свою интуицию :)

Импорты и экспорты лучше всего демонстрировать живым кодированием!

### Экспорт по умолчанию и именованный экспорт

- Экспорт по умолчанию: `export default`
- Именованный экспорт: `export {<var1>, <var2>, ...}`

### Импортирование с пространствами имен

- По умолчанию: `import <some-name> from <path>`
- Именованный: `import { <var1>, <var2> } from <path>`
- Комбинированный импорт с пользовательским именем: `import * as <some-name> from <path>`